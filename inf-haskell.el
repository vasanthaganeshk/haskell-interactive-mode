;;; inf-haskell.el --- Interaction with an inferior Haskell process -*- lexical-binding: t -*-

;; Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.
;; Copyright (C) 2017 Vasantha Ganesh Kanniappan <vasanthaganesh.k@tuta.io>

;; Author: Stefan Monnier <monnier@iro.umontreal.ca>
;; Keywords: Haskell

;; This file is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.

;; This file is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; A major mode for the buffer that holds the inferior process

;; Todo:

;; - Check out Shim for ideas.
;; - i-h-load-buffer and i-h-send-region.

;;; Code:

(require 'comint)
(require 'shell)             ; For directory tracking.
(require 'etags)
(require 'haskell-compat)
(require 'compile)
(require 'haskell-mode)
(require 'haskell-decl-scan)
(require 'haskell-cabal)
(require 'haskell-customize)
(require 'cl-lib)

;; Dynamically scoped variables.
(defvar find-tag-marker-ring)

;;;###autoload
(defgroup inferior-haskell nil
  "Settings for REPL interaction via `inferior-haskell-mode'"
  :link '(custom-manual "(haskell-mode)inferior-haskell-mode")
  :prefix "inferior-haskell-"
  :prefix "haskell-"
  :group 'haskell)

(defun haskell-program-name-with-args ()
  "returns what command to run based on the situation with the arguments
for repl"
  (cl-ecase (haskell-process-type)
    ('ghci       (cond ((eq system-type 'cygwin) (nconc "ghcii.sh"
                                                     haskell-process-args-ghci))
                       (t (nconc `(,haskell-process-path-ghci)
                                 haskell-process-args-ghci))))
    ('cabal-repl (nconc `(,haskell-process-path-cabal
                          "repl")
                        haskell-process-args-cabal-repl))
    ('stack-ghci (nconc `(,haskell-process-path-stack
                          "ghci")
                        haskell-process-args-stack-ghci))))

(defconst inferior-haskell-info-xref-re
  "\t-- Defined at \\(.+\\):\\([0-9]+\\):\\([0-9]+\\)\\(?:-\\([0-9]+\\)\\)?$")

(defconst inferior-haskell-module-re
  "\t-- Defined in \\(.+\\)$"
  "Regular expression for matching module names in :info.")

(defvar inferior-haskell-multiline-prompt-re
  "^\\*?[[:upper:]][\\._[:alnum:]]*\\(?: \\*?[[:upper:]][\\._[:alnum:]]*\\)*| "
  "Regular expression for matching multiline prompt (the one inside :{ ... :} blocks).")

(defconst inferior-haskell-error-regexp-alist
  ;; The format of error messages used by Hugs.
  `(("^ERROR \"\\(.+?\\)\"\\(:\\| line \\)\\([0-9]+\\) - " 1 3)
    ;; Format of error messages used by GHCi.
    ("^\\(.+?\\):\\([0-9]+\\):\\(\\([0-9]+\\):\\)?\\( \\|\n *\\)\\([Ww]arning\\)?"
     1 2 4 ,@(if (fboundp 'compilation-fake-loc)
                 '((6) nil (5 '(face nil font-lock-multiline t)))))
    ;; Runtime exceptions, from ghci.
    ("^\\*\\*\\* Exception: \\(.+?\\):(\\([0-9]+\\),\\([0-9]+\\))-(\\([0-9]+\\),\\([0-9]+\\)): .*"
     1 ,@(if (fboundp 'compilation-fake-loc) '((2 . 4) (3 . 5)) '(2 3)))
    ;; GHCi uses two different forms for line/col ranges, depending on
    ;; whether it's all on the same line or not :-( In Emacs-23, I could use
    ;; explicitly numbered subgroups to merge the two patterns.
    ("^\\*\\*\\* Exception: \\(.+?\\):\\([0-9]+\\):\\([0-9]+\\)-\\([0-9]+\\): .*"
     1 2 ,(if (fboundp 'compilation-fake-loc) '(3 . 4) 3))
    ;; Info messages.  Not errors per se.
    ,@(when (fboundp 'compilation-fake-loc)
        `(;; Other GHCi patterns used in type errors.
          ("^[ \t]+at \\(.+\\):\\([0-9]+\\):\\([0-9]+\\)-\\([0-9]+\\)$"
           1 2 (3 . 4) 0)
          ;; Foo.hs:318:80:
          ;;     Ambiguous occurrence `Bar'
          ;;     It could refer to either `Bar', defined at Zork.hs:311:5
          ;;                  or `Bar', imported from Bars at Frob.hs:32:0-16
          ;;                       (defined at Location.hs:97:5)
          ("[ (]defined at \\(.+\\):\\([0-9]+\\):\\([0-9]+\\))?$" 1 2 3 0)
          ("imported from .* at \\(.+\\):\\([0-9]+\\):\\([0-9]+\\)-\\([0-9]+\\)$"
           1 2 (3 . 4) 0)
          ;; Info xrefs.
          (,inferior-haskell-info-xref-re 1 2 (3 . 4) 0))))
  "Regexps for error messages generated by inferior Haskell processes.
The format should be the same as for `compilation-error-regexp-alist'.")
(defconst haskell-prompt-regexp
  ;; Why the backslash in [\\._[:alnum:]]?
  "^\\*?[[:upper:]][\\._[:alnum:]]*\\(?: \\*?[[:upper:]][\\._[:alnum:]]*\\)*\\( λ\\)?> \\|^λ?> $")

;;; TODO
;;; -> Make font lock work for strings, directories, hyperlinks
;;; -> Make font lock work for key words???

(define-derived-mode inferior-haskell-mode comint-mode "Inf-Haskell"
  "Major mode for interacting with an inferior Haskell process."
  :group 'inferior-haskell
  (setq-local comint-prompt-regexp haskell-prompt-regexp)

  (setq-local paragraph-start haskell-prompt-regexp)

  (setq-local comint-input-autoexpand nil)
  (setq-local comint-prompt-read-only t)

  (add-hook 'comint-preoutput-filter-functions
            'inferior-haskell-send-decl-post-filter)
  (add-hook 'comint-output-filter-functions 'inferior-haskell-spot-prompt nil t)
  ;; Setup directory tracking.
  (setq-local shell-cd-regexp ":cd")
  (condition-case nil
      (shell-dirtrack-mode 1)
    (error      ;The minor mode function may not exist or not accept an arg.
     (setq-local shell-dirtrackp t)
     (add-hook 'comint-input-filter-functions 'shell-directory-tracker
               nil 'local)))

  ;; Setup `compile' support so you can just use C-x ` and friends.
  (setq-local compilation-error-regexp-alist inferior-haskell-error-regexp-alist)
  (setq-local compilation-first-column 0) ;GHCI counts from 0.
  (if (and (not (boundp 'minor-mode-overriding-map-alist))
           (fboundp 'compilation-shell-minor-mode))
      ;; If we can't remove compilation-minor-mode bindings, at least try to
      ;; use compilation-shell-minor-mode, so there are fewer
      ;; annoying bindings.
      (compilation-shell-minor-mode 1)
    ;; Else just use compilation-minor-mode but without its bindings because
    ;; things like mouse-2 are simply too annoying.
    (compilation-minor-mode 1)
    (let ((map (make-sparse-keymap)))
      (dolist (keys '([menu-bar] [follow-link]))
        ;; Preserve some of the bindings.
        (define-key map keys (lookup-key compilation-minor-mode-map keys)))
      (add-to-list 'minor-mode-overriding-map-alist
                   (cons 'compilation-minor-mode map)))))

(defvar inferior-haskell-buffer nil
  "The buffer in which the inferior process is running.")

(defun inferior-haskell-start-process ()
  "Start an inferior haskell process.
With universal prefix \\[universal-argument], prompts for a COMMAND,
otherwise uses `haskell-program-name-with-args'.
It runs the hook `inferior-haskell-hook' after starting the process and
setting up the inferior-haskell buffer."
  (let ((command (haskell-program-name-with-args)))
    (setq inferior-haskell-buffer
          (apply 'make-comint "haskell" (car command) nil (cdr command)))
    (with-current-buffer inferior-haskell-buffer
      (inferior-haskell-mode)
      (run-hooks 'inferior-haskell-hook))))

(defun inferior-haskell-process ()
  "restart if not present"
  (cond ((buffer-live-p inferior-haskell-buffer)
         (get-buffer-process inferior-haskell-buffer))
        (t (inferior-haskell-start-process)
           (inferior-haskell-process))))

;;;###autoload
(defalias 'run-haskell 'switch-to-haskell)
;;;###autoload
(defun switch-to-haskell ()
  "Show the inferior-haskell buffer.  Start the process if needed."
  (interactive)
  (let ((proc (inferior-haskell-process)))
    (pop-to-buffer-same-window (process-buffer proc))))

(defcustom inferior-haskell-wait-and-jump nil
  "If non-nil, wait for file loading to terminate and jump to the error."
  :type 'boolean
  :group 'inferior-haskell)

(defvar-local inferior-haskell-send-decl-post-filter-on nil)

(defun inferior-haskell-send-decl-post-filter (string)
  (when (and inferior-haskell-send-decl-post-filter-on
             (string-match inferior-haskell-multiline-prompt-re string))
    ;; deleting sequence of `%s|' multiline promts
    (while (string-match inferior-haskell-multiline-prompt-re string)
      (setq string (substring string (match-end 0))))
    ;; deleting regular prompts
    (setq string (replace-regexp-in-string comint-prompt-regexp "" string)
          ;; turning off this post-filter
          inferior-haskell-send-decl-post-filter-on nil))
  string)

(defvar-local inferior-haskell-seen-prompt nil)

(defun inferior-haskell-spot-prompt (_string)
  (let ((proc (get-buffer-process (current-buffer))))
    (when proc
      (save-excursion
        (goto-char (process-mark proc))
        (if (re-search-backward comint-prompt-regexp
                                (line-beginning-position) t)
            (setq inferior-haskell-seen-prompt t))))))

(defun inferior-haskell-wait-for-prompt (proc &optional timeout)
  "Wait until PROC sends us a prompt.
The process PROC should be associated to a comint buffer."
  (with-current-buffer (process-buffer proc)
    (while (progn
             (goto-char comint-last-input-end)
             (not (or inferior-haskell-seen-prompt
                      (setq inferior-haskell-seen-prompt
                            (re-search-forward comint-prompt-regexp nil t))
                      (not (accept-process-output proc timeout))))))
    (unless inferior-haskell-seen-prompt
      (error "Can't find the prompt"))))

(defvar inferior-haskell-cabal-buffer nil)

(defun inferior-haskell-cabal-of-buf (buf)
  (with-current-buffer buf
    (or (and (buffer-live-p inferior-haskell-cabal-buffer)
             inferior-haskell-cabal-buffer)
        (if (local-variable-p 'inferior-haskell-cabal-buffer
                              ;; XEmacs needs this argument.
                              (current-buffer))
            inferior-haskell-cabal-buffer
          (setq-local inferior-haskell-cabal-buffer (haskell-cabal-find-file))))))

(defvar inferior-haskell-run-command ":main")

(defun inferior-haskell-send-command (proc str)
  (setq str (concat str "\n"))
  (with-current-buffer (process-buffer proc)
    (inferior-haskell-wait-for-prompt proc)
    (goto-char (process-mark proc))
    (insert-before-markers str)
    (move-marker comint-last-input-end (point))
    (setq inferior-haskell-seen-prompt nil)
    (comint-send-string proc str)))

(defun inferior-haskell-wrap-decl (code)
  "Wrap declaration code into :{ ... :}."
  (setq code (concat code "\n"))
  (concat ":{\n"
          (if (string-match (concat "^\\s-*"
                                    haskell-ds-start-keywords-re)
                            code)
              ;; non-fun-decl
              code
            ;; fun-decl, wrapping into let { .. (; ..)* }
            (concat "let {\n"
                    (mapconcat
                     ;; adding 2 whitespaces to each line
                     (lambda (decl)
                       (mapconcat (lambda (s)
                                    (concat "  " s))
                                  (split-string decl "\n")
                                  "\n"))
                     ;; splitting function case-decls
                     (let (decls)
                       (while (string-match "^\\(\\w+\\).*\n*\\(?:\\s-+.*\n+\\)*" code)
                         (push (match-string 0 code) decls)
                         (setq code (substring code (match-end 0))))
                       (reverse decls))
                     "\n;\n")
                    "\n}"))
          "\n:}\n"))

(defun inferior-haskell-flash-decl (start end &optional timeout)
  "Temporarily highlight declaration."
  (let ((overlay (make-overlay start end)))
    (overlay-put overlay 'face 'secondary-selection)
    (run-with-timer (or timeout 0.2) nil 'delete-overlay overlay)))

(defun inferior-haskell-get-result (inf-expr)
  "Submit the expression `inf-expr' to ghci and read the result."
  (let ((proc (inferior-haskell-process)))
    (with-current-buffer (process-buffer proc)
      (let ((parsing-end                ; Remember previous spot.
             (marker-position (process-mark proc))))
        (inferior-haskell-send-command proc inf-expr)
        ;; Find new point.
        (inferior-haskell-wait-for-prompt proc)
        (goto-char (point-max))
        ;; Back up to the previous end-of-line.
        (end-of-line 0)
        ;; Extract the output
        (buffer-substring-no-properties
         (save-excursion (goto-char parsing-end)
                         (line-beginning-position 2))
         (point))))))

;;;###autoload
(defun inferior-haskell-info (sym)
  "Query the haskell process for the info of the given expression."
  (interactive
   (let ((sym (haskell-ident-at-point)))
     (list (read-string (if sym
                            (format "Show info of (default %s): " sym)
                          "Show info of: ")
                        nil nil sym))))
  (let ((result (inferior-haskell-get-result (concat ":info " sym))))
    (if (called-interactively-p 'any) (message "%s" result))
    result))

;;; Functions to find the documentation of a given function.
;;
;; TODO for this section:
;;
;; * Support fetching of local Haddock docs pulled directly from source files.
;; * Display docs locally? w3m?

(defcustom inferior-haskell-use-web-docs
  'fallback
  "Whether to use the online documentation.  Possible values:
`never', meaning always use local documentation, unless the local
file doesn't exist, when do nothing, `fallback', which means only
use the online documentation when the local file doesn't exist,
or `always', meaning always use the online documentation,
regardless of existance of local files.  Default is `fallback'."
  :group 'inferior-haskell
  :type '(choice (const :tag "Never" never)
                 (const :tag "As fallback" fallback)
                 (const :tag "Always" always)))

(defcustom inferior-haskell-web-docs-base
  "http://haskell.org/ghc/docs/latest/html/libraries/"
  "The base URL of the online libraries documentation.
This will only be used if the value of `inferior-haskell-use-web-docs'
is `always' or `fallback'."
  :group 'inferior-haskell
  :type 'string)

(defcustom haskell-package-manager-name "ghc-pkg"
  "Name of the program to consult regarding package details."
  :group 'inferior-haskell
  :type 'string)

(defcustom haskell-package-conf-file
  (condition-case nil
      (with-temp-buffer
        (call-process "ghc" nil t nil "--print-libdir")
        (expand-file-name "package.conf"
                          (buffer-substring (point-min) (1- (point-max)))))
    ;; Don't use `ignore-errors' because this form is not byte-compiled :-(
    (error nil))
  "Where the package configuration file for the package manager resides.
By default this is set to `ghc --print-libdir`/package.conf."
  :group 'inferior-haskell
  :type 'string)

(defun inferior-haskell-get-module (sym)
  "Fetch the module in which SYM is defined."
  (let ((info (inferior-haskell-info sym)))
    (unless (string-match inferior-haskell-module-re info)
      (error
       "No documentation information available.  Did you forget to C-c C-l?"))
    (let* ((module-name (match-string-no-properties 1 info))
          (first-character (substring module-name 0 1)))
      ;; Handles GHC 7.4.1+ which quotes module names like
      ;; `System.Random', whereas previous GHC did not quote at all.
      (if (or (string= "`" first-character) (string= "‘" first-character))

          (substring module-name 1 (- (length module-name) 1))
        module-name))))

(defun inferior-haskell-query-ghc-pkg (&rest args)
  "Send ARGS to `haskell-package-manager-name'.
Insert the output into the current buffer."
  (apply 'call-process haskell-package-manager-name nil t nil args))

(defun inferior-haskell-get-package-list ()
  "Get the list of packages from `haskell-package-manager-name'."
  (with-temp-buffer
    (inferior-haskell-query-ghc-pkg "--simple-output" "list")
    (split-string (buffer-substring (point-min) (point-max)))))

(defun inferior-haskell-compute-module-alist ()
  "Compute a list mapping modules to package names and haddock URLs using ghc-pkg."
  (message "Generating module alist...")
  (let ((module-alist ()))
    (with-temp-buffer
      (dolist (package (inferior-haskell-get-package-list))
        (erase-buffer)
        (inferior-haskell-query-ghc-pkg "describe" package)

        (let ((package-w/o-version
               (replace-regexp-in-string "[-.0-9]*\\'" "" package))
              ;; Find the Haddock documentation URL for this package
              (haddock
               (progn
                 (goto-char (point-min))
                 (when (re-search-forward "haddock-html:[ \t]+\\(.*[^ \t\n]\\)"
                                          nil t)
                   (match-string 1)))))

          ;; Fetch the list of exposed modules for this package
          (goto-char (point-min))
          (when (re-search-forward "^exposed-modules:\\(.*\\(\n[ \t].*\\)*\\)"
                                   nil t)
            (dolist (module (split-string (match-string 1)))
              (push (list module package-w/o-version haddock)
                    module-alist)))))

      (message "Generating module alist... done")
      module-alist)))

(defcustom inferior-haskell-module-alist-file
  ;; (expand-file-name "~/.inf-haskell-module-alist")
  (expand-file-name (concat "inf-haskell-module-alist-"
                            (number-to-string (user-uid)))
                    temporary-file-directory)
  "Where to save the module -> package lookup table.
Set this to nil to never cache to a file."
  :group 'inferior-haskell
  :type '(choice (const :tag "Don't cache to file" nil) string))

(defvar inferior-haskell-module-alist nil
  "Association list of modules to their packages.
Each element is of the form (MODULE PACKAGE HADDOCK), where
MODULE is the name of a module,
PACKAGE is the package it belongs to, and
HADDOCK is the path to that package's Haddock documentation.

This is calculated on-demand using `inferior-haskell-compute-module-alist'.
It's also cached in the file `inferior-haskell-module-alist-file',
so that it can be obtained more quickly next time.")

(defun inferior-haskell-module-alist ()
  "Get the module alist from cache or ghc-pkg's info."
  (or
   ;; If we already have computed the alist, use it...
   inferior-haskell-module-alist
   (setq inferior-haskell-module-alist
         (or
          ;; ...otherwise try to read it from the cache file...
          (and
           inferior-haskell-module-alist-file
           (file-readable-p inferior-haskell-module-alist-file)
           (file-newer-than-file-p inferior-haskell-module-alist-file
                                   haskell-package-conf-file)
           (with-temp-buffer
             (insert-file-contents inferior-haskell-module-alist-file)
             (goto-char (point-min))
             (prog1 (read (current-buffer))
               (message "Read module alist from file cache."))))

          ;; ...or generate it again and save it in a file for later.
          (let ((alist (inferior-haskell-compute-module-alist)))
            (when inferior-haskell-module-alist-file
              (with-temp-buffer
                (print alist (current-buffer))
                ;; Do the write to a temp file first, then rename it.
                ;; This makes it more atomic, and suffers from fewer security
                ;; holes related to race conditions if the file is in /tmp.
                (let ((tmp (make-temp-file inferior-haskell-module-alist-file)))
                  (write-region (point-min) (point-max) tmp)
                  (rename-file tmp inferior-haskell-module-alist-file
                               'ok-if-already-exists))))
            alist)))))

(defvar inferior-haskell-ghc-internal-ident-alist
  ;; FIXME: Fill this table, ideally semi-automatically.
  '(("GHC.Base.return" . "Control.Monad.return")
    ("GHC.Base.String" . "Data.String.String")
    ("GHC.List"        . "Data.List")))

(defun inferior-haskell-map-internal-ghc-ident (ident)
  "Try to translate some internal GHC identifier to its alter ego in haskell docs."
  (let ((head ident)
        (tail "")
        remapped)
    (while (and (not
                 (setq remapped
                       (cdr (assoc head
                                   inferior-haskell-ghc-internal-ident-alist))))
                (string-match "\\.[^.]+\\'" head))
      (setq tail (concat (match-string 0 head) tail))
      (setq head (substring head 0 (match-beginning 0))))
    (concat (or remapped head) tail)))

(provide 'inf-haskell)

;;; inf-haskell.el ends here
